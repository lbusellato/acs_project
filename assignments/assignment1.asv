%--------------------------------------------------------------------------
%
% Assignment 1: DH parameters, direct and inverse kinematics, Jacobian
% matrices.
%
% Author: Lorenzo Busellato, VR472249, 2022
%
%--------------------------------------------------------------------------

%% SETUP

clc;
clearvars;
close all;
addpath(genpath('../common/'));
% Load the robot struct
robotStruct;

%% DIRECT KINEMATICS

fprintf('Base to ee transformation matrix:');
T0_ee = robot.T(:,:,5)
ee_pose = subs(T0_ee(1:3,4), robot.q, [0 0 0].');
fprintf('EE position using my direct kinematics: [%.2f %.2f %.2f]\n', ee_pose(1), ee_pose(2), ee_pose(3))
ee_pose = robot.toolboxT(1:3,4);
fprintf('EE position using the toolbox direct kinematics: [%.2f %.2f %.2f]\n\n', ee_pose(1), ee_pose(2), ee_pose(3))

%% INVERSE KINEMATICS

robot.config = randomConfiguration(robot.urdf);
fprintf('Actual configuration: [%.2f %.2f %.2f]\n', robot.config.JointPosition)
config = myInverseKinematics(robot);
fprintf('Configuration from my inverse kinematics: [%.2f %.2f %.2f]\n', config)
config = toolboxInverseKinematics(robot);
fprintf('Configuration from the toolbox inverse kinematics: [%.2f %.2f %.2f]\n\n', config)

%% JACOBIANS
fprintf('Analytical expression for JG:');
robot.JG
fprintf('My JG evaluated in the current robot config:');
JG = vpa(subs(robot.JG, robot.q, [robot.config.JointPosition].'),3)
fprintf('Too')




