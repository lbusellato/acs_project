%--------------------------------------------------------------------------
%
% Assignment 1: DH parameters, direct and inverse kinematics, Jacobian
% matrices.
%
% Author: Lorenzo Busellato, VR472249, 2022
%
%--------------------------------------------------------------------------

%% SETUP

close all;
clc;
clearvars;
addpath(genpath('../functions/'));
% Load the robot's URDF
robot_urdf = importrobot('../RPR_zyx.urdf');
% Load the robot parameter struct
robotStruct; clc;
% Show details of the robot (link/joint names and connections)
showdetails(robot_urdf)

% Set up a figure to display the robot
figure;
config = homeConfiguration(robot_urdf);
show(robot_urdf, config);
xlim([-1 1]);
ylim([-1 1]);
zlim([0 0.6]);

%% DIRECT KINEMATICS

% Move the robot to a random pose
config = randomConfiguration(robot_urdf);
% Check my direct kinematics against the toolbox's estimation
checkDirectKinematics(robot_urdf, robot, config);

%% 
syms x y z
Rx = [1,0,0;0,cos(x),-sin(x);0,sin(x),cos(x)];
Ry = [cos(y),0,sin(y);0,1,0;-sin(y),0,cos(y)];
Rz = [cos(z),-sin(z),0;sin(z),cos(z),0;0,0,1];
zyx = simplify(Rz*Ry*Rx)
zyz = simplify(Rz*Ry*Rz)
zxz = simplify(Rz*Rx*Rz)
zxy = simplify(Rz*Rx*Ry)
Ti(1:3,1:3,4)*[0,0,1;0,1,0;-1,0,0]

%% INVERSE KINEMATICS

% Move the robot to a random pose
config = randomConfiguration(robot_urdf);
toolbox_base_to_ee = getTransform(robot_urdf, config, 'ee', 'base_link');
ee_pose = toolbox_base_to_ee(1:3,4);
toolbox_base_to_w = getTransform(robot_urdf, config, 'Link4', 'base_link');
w_pose = toolbox_base_to_w(1:3,4);
% Compute inverse kinematics "by hand"
[q1, q2, q3] = myInverseKinematics(robot, ee_pose, w_pose)
% Check the computed inverse kinematics against the toolbox's estimation
checkInverseKinematics(robot_urdf, config);

%% JACOBIANS

% Move the robot to a random pose
config = randomConfiguration(robot_urdf);
% Compare my analytical and geometric Jacobian with the toolbox's
checkJacobians(robot_urdf, robot, config);